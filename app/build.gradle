
class ApkAutoInstallExtension {
    Closure nameMap = null
    String destDir = null
}

class ApkAutoInstall implements Plugin<Project> {

    private AppExtension androidExt

    @Override
    void apply(Project target) {
        this.androidExt = target.extensions.getByName("android") as AppExtension
        println 'task add ApkAutoInstall'
        target.extensions.create("apkautoconf", ApkAutoInstallExtension)

        target.task("installApp")  {
            doLast {
                def closure = target['apkautoconf'].nameMap
                closure('wefdff')
                println project['apkautoconf'].destDir
            }
        }

        /*target.afterEvaluate {
            androidExt.applicationVariants.each { variant ->
                println('00--------0000='+variant.name)
                def javaCompileTask = variant.javaCompiler
                int processorIndex = javaCompileTask.options.compilerArgs.indexOf('-processorpath')
                def processor = javaCompileTask.options.compilerArgs.get(processorIndex + 1)
                processor.split(File.pathSeparator).each { jarPath ->
                    println "----------find compiler jar path: ${jarPath}"
                }
            }
        }*/

    }
}


apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply plugin: 'kotlin-kapt'
apply plugin: ApkAutoInstall
apply plugin: MyTestPlugin


apkautoconf {
    nameMap { arg1 ->
        println('========nameMap=====' + arg1)
    }
    destDir '==========mydddirrr'
}

configurations.all {
    resolutionStrategy {
        eachDependency { DependencyResolveDetails details ->
            //specifying a fixed version for all libraries with 'org.gradle' group
//            println 'depen:'+details.requested.group+':'+details.requested.name+':'+details.requested.version
        }

//        failOnVersionConflict()
        //preferProjectModules()
    }
}


def setValueByName(def obj,Class kcCls,def name,def value){
    println('setValueByName ==== class ='+kcCls.getName())
    Field[] fds = kcCls.getDeclaredFields()
    for (int i=0;i<fds.length;i++){
        println('====fd='+fds[i].name)
    }

    Method[] mds = kcCls.getDeclaredMethods()
    for (int i=0;i<mds.length;i++){
        println('====md='+mds[i].name)
    }
    Field sourceSetNameField = kcCls.getDeclaredField(name)
    sourceSetNameField.setAccessible(true)
    sourceSetNameField.set(obj,value)
}

task compilesingle(type:JavaCompile,group:'myself'){

    def classePathList = new ArrayList()

    doFirst {
        project.getTasks().all {
            if (it.name.equals('compileDebugKotlin')){
                KotlinCompile ktask = it
                println('vvbbmm============'+it.getClass())
                ktask.getClasspath().each { File file->
                    println('===------:'+file)
                    classePathList.add(file.absolutePath)
                }
            }
        }
        File classDir = new File(project.buildDir,'intermediates/classes/debug')
        File oldKotlinClassDir = new File(project.getBuildDir(),'tmp/kotlin-classes/debug')
        if (!classDir.exists() ){
            classDir = new File(project.buildDir,'intermediates/classes/release')
        }
        classePathList.add(oldKotlinClassDir)
        classePathList.add(classDir)
    }
    List<String> includes = new ArrayList<>()
    includes.add('com/shobal/gradlepractise/Mycctt.java')
//    includes.add('com/shobal/gradlepractise/MyTest.kt')
    includes.add('com/shobal/gradlepractise/Mycctt2.java')

    source = './src/main/java'
//    include "com/shobal/gradlepractise/MainActivity.java" //MyContants
//    classpath = project.files(classePathList)
    include includes //MyContants
    classpath = project.files()
    destinationDir = project.file('./bin')
}

gradle.getTaskGraph().whenReady {
    project.tasks.all {
        if (it.name.equalsIgnoreCase('compileJava')) {
            println "=====+++++" + it.getPath()
            printTaskDependency(it, "")
        }
    }
}

void printTaskDependency(Task task, String divider) {
    divider += "-------"
    task.getTaskDependencies().getDependencies(task).any() {
        println('====+++' + divider + it.getPath())
        if (it.getPath().contains(":credit")) {
            printTaskDependency(it, divider)
        }
    }
}


android {
    compileSdkVersion 25
    buildToolsVersion "26.0.2"
    defaultConfig {
        applicationId "com.shobal.gradlepractise"
        minSdkVersion 18
        targetSdkVersion 25
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [tp: "dfsdf"]
                classNames = ["shobal.compilehandler.CompilerProcesser"]
//                includeCompileClassPath true
            }
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
    /*lintOptions {
        abortOnError false
    }*/

}

kapt {
    arguments {
        arg("key", "value")
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    /*androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })*/
    implementation 'com.android.support:appcompat-v7:25.3.1'
    implementation 'com.android.support:design:25.3.1'
    implementation project(':applibrary')
    implementation project(':myjavalib')
    implementation project(':annotatiom')
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
//    annotationProcessor project(':Compilehandler')
    kapt project(":Compilehandler")

    testImplementation 'junit:junit:4.12'
}

/*-------------*/

class RegisterTransform implements Plugin<Project> {

    @Override
    void apply(Project target) {
        def isApp = target.plugins.hasPlugin(AppPlugin)
        println '-----register MyTransform------' + isApp
        if (isApp) {
            println '-----register MyTransform------' + target.android.bootClasspath[0].toString()
            target.android.registerTransform(new MyTransform(target.android.bootClasspath[0].toString()))
        }
    }
}


import com.android.build.api.transform.*
import com.android.build.gradle.AppExtension
import com.android.build.gradle.AppPlugin
import com.plugin.demo.MyInject
import org.apache.commons.io.FileUtils
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import org.jetbrains.kotlin.gradle.tasks.KotlinTasksProvider

import java.lang.reflect.Field
import java.lang.reflect.Method

class MyTransform extends Transform {
    String mAndClassPath

    public MyTransform(String androidClassPaht) {
        mAndClassPath = androidClassPaht
    }

    @Override
    String getName() {//这个名称会用于生成的gradle task名称
        return "LogInject"
    }

    @Override
    Set<QualifiedContent.ContentType> getInputTypes() {
        //接受输入的类型。我们这里只处理Java类。
        return [QualifiedContent.DefaultContentType.CLASSES]
    }

    @Override
    Set<QualifiedContent.Scope> getScopes() {
        //作用范围。这里我们只处理工程中编写的类。
        return [QualifiedContent.Scope.PROJECT]
    }

    @Override
    boolean isIncremental() {//是否支持增量。这里暂时不实现增量。
        return false
    }

    @Override
    void transform(
            Context context,
            Collection<TransformInput> inputs,
            Collection<TransformInput> referencedInputs,
            TransformOutputProvider outputProvider, boolean isIncremental) throws IOException, TransformException, InterruptedException {
        // Transform的inputs有两种类型，一种是目录，一种是jar包，要分开遍历
        inputs.each { TransformInput input ->
            //对类型为“文件夹”的input进行遍历
            input.directoryInputs.each { DirectoryInput directoryInput ->
                //文件夹里面包含的是我们手写的类以及R.class、BuildConfig.class以及R$XXX.class等
                MyInject.injectDir(directoryInput.file.absolutePath, 'com.shobal.gradlepractise', 'MainActivity', mAndClassPath)

                // 获取output目录
                def dest = outputProvider.getContentLocation(directoryInput.name,
                        directoryInput.contentTypes, directoryInput.scopes,
                        Format.DIRECTORY)

                // 将input的目录复制到output指定目录
                FileUtils.copyDirectory(directoryInput.file, dest)
                println '---------=====' + directoryInput.file.absolutePath + '--copy dir to--' + dest.absolutePath
            }
            //对类型为jar文件的input进行遍历
            input.jarInputs.each { JarInput jarInput ->

                //jar文件一般是第三方依赖库jar文件

                // 重命名输出文件（同目录copyFile会冲突）
                def jarName = jarInput.name
                def md5Name = DigestUtils.md5Hex(jarInput.file.getAbsolutePath())
                if (jarName.endsWith(".jar")) {
                    jarName = jarName.substring(0, jarName.length() - 4)
                }

                //生成输出路径
                def dest = outputProvider.getContentLocation(jarName + md5Name,
                        jarInput.contentTypes, jarInput.scopes, Format.JAR)
                //将输入内容复制到输出
                FileUtils.copyFile(jarInput.file, dest)
                println '---------=====' + jarInput.file.absolutePath + '--copy jar to--' + dest.absolutePath
            }
        }
    }
}

apply plugin: RegisterTransform
repositories {
    mavenCentral()
}


// Log timings per task.
class BuildTimeListener implements TaskExecutionListener, BuildListener {
    private Clock clock
    private times = []

    @Override
    void beforeExecute(Task task) {
        clock = new org.gradle.util.Clock()
    }

    @Override
    void afterExecute(Task task, TaskState taskState) {
        def ms = clock.timeInMs
        times.add([ms, task.path])

        //task.project.logger.warn "${task.path} spend ${ms}ms"
    }

    @Override
    void buildFinished(BuildResult result) {
        println "Task spend time:"
        int totalTime = 0
        /*times.sort {
            it[0]
        }*/
        times = times.reverse()
        for (time in times) {
            if (time[0] >= 50) {
                printf "%7sms  %s\n", time
            }
            totalTime += time[0]
        }

        int mins = 0
        if (totalTime > 60000) {
            mins = totalTime / 60000
            totalTime = totalTime % 60000
        }
        float second = 0
        if (totalTime > 1000) {
            second = totalTime
            second = totalTime / 1000
        }

        println "Build Task spend total time: ${mins} mins ${second} secs"
    }

    @Override
    void buildStarted(Gradle gradle) {}

    @Override
    void projectsEvaluated(Gradle gradle) {}

    @Override
    void projectsLoaded(Gradle gradle) {}

    @Override
    void settingsEvaluated(Settings settings) {}
}

project.gradle.addListener(new BuildTimeListener())

//执行的task的所有依赖
/*gradle.addListener(new TaskExecutionGraphListener() {
    @Override
    void graphPopulated(TaskExecutionGraph graph) {
        gradle.println "=========from gradle.addListener graphPopulated========="
        graph.allTasks.each {
            Task task ->
                gradle.println "=========TaskExecutionGraph:${task.getName()}========="
        }
    }
})*/

//依赖监听
/*gradle.addListener(new DependencyResolutionListener() {
    @Override
    void beforeResolve(ResolvableDependencies resolvableDependencies) {
        gradle.println "DependencyResolutionListener:beforeResolve:=====${dependencies}====="

    }

    @Override
    void afterResolve(ResolvableDependencies resolvableDependencies) {
        gradle.println "DependencyResolutionListener:afterResolve:=====${dependencies}====="

        def projectPath = resolvableDependencies.path.toLowerCase()

        if (projectPath.contains("releasecompile")) {
            gradle.println "[DependencyResolutionListener] release detect:${resolvableDependencies.path}"
            resolvableDependencies.resolutionResult.allDependencies.each { dependency ->
                if (dependency instanceof org.gradle.api.internal.artifacts.result.DefaultUnresolvedDependencyResult) {
                    gradle.println "DefaultUnresolvedDependencyResult reason: ${dependency.reason}"
                    gradle.println "DefaultUnresolvedDependencyResult failure: ${dependency.failure}"
                } else if (dependency instanceof org.gradle.api.internal.artifacts.result.DefaultResolvedDependencyResult) {
                    String selected = dependency.selected
                    def from = dependency.from
                    gradle.println "[DependencyResolutionListener] current dependency:${selected} which is from:${from}"
                    if (selected != null && (selected.toLowerCase().contains("snapshot") || selected.toLowerCase().contains("beta"))) {
                        String errorMessage = "[DependencyResolutionListener] [Error] ${selected} from ${from} contains a snapshot or beta version. you must fix it."
                        gradle.println errorMessage
                        throw new IllegalStateException(errorMessage)
                    }
                }
            }
        }
    }
})*/

//当前构建的任务依赖关系图
/*gradle.taskGraph.whenReady {
    TaskExecutionGraph taskGraph ->
        taskGraph.allTasks.each {
            Task task ->
                gradle.println "=========whenReady:taskGraph:${task.getName()}========="
        }
        taskGraph.beforeTask {
            Task task ->
                gradle.println "=========whenReady:beforeTask:${task.getName()}========="
        }
        taskGraph.afterTask {
            Task task ->
                gradle.println "=========whenReady:afterTask:${task.getName()}========="
        }
}*/
//等同于上面的whenReady闭包中的内容
/*gradle.taskGraph.addTaskExecutionGraphListener(new TaskExecutionGraphListener() {
    @Override
    void graphPopulated(TaskExecutionGraph graph) {
        gradle.println "=========TaskExecutionGraphListener:graphPopulated========="
        graph.allTasks.each {
            Task task ->
                gradle.println "=========TaskExecutionGraph:${task.getName()}========="
        }
    }
})*/

//等同于上面的whenReady闭包中的内容
/*gradle.taskGraph.addTaskExecutionListener(new TaskExecutionListener() {
    @Override
    void beforeExecute(Task task) {
        gradle.println "=========TaskExecutionListener:beforeExecute:${task.getName()}========="

    }

    @Override
    void afterExecute(Task task, TaskState state) {
        gradle.println "=========TaskExecutionListener:afterExecute:${task.getName()}========="
        gradle.println "=========TaskState:[executed]${state.executed}========="
        gradle.println "=========TaskState:[didWork]${state.didWork}========="
        gradle.println "=========TaskState:[failure]${state.failure}========="
        gradle.println "=========TaskState:[skipMessage]${state.skipMessage}========="
        gradle.println "=========TaskState:[skipped]${state.skipped}========="
        gradle.println "=========TaskState:[upToDate]${state.upToDate}========="
    }
})*/

//配置评估监听
/*gradle.addProjectEvaluationListener(new ProjectEvaluationListener() {
    @Override
    void beforeEvaluate(Project project) {
        //项目配置评估前回调
        gradle.println("=========ProjectEvaluationListener:beforeEvaluate ${project.getName()}=========")
    }

    @Override
    void afterEvaluate(Project project, ProjectState state) {
        //项目配置评估后回调
        //如果失败,则failure不为null
        gradle.println("=========ProjectEvaluationListener:afterEvaluate ${state.executed} ${state.failure}=========")
    }
})*/

/**
 * 同上BuildListener和ProjectEvaluationListener
 */
/*gradle.buildFinished {
    gradle.println "=========buildFinished========="
}
gradle.buildStarted {
    gradle.println "=========buildStarted========="
}
gradle.settingsEvaluated {
    gradle.println "=========settingsEvaluated========="
}
gradle.projectsLoaded {
    gradle.println "=========projectsLoaded========="
}
gradle.projectsEvaluated {
    gradle.println "=========projectsEvaluated========="
}
gradle.buildFinished {
    gradle.println "=========buildFinished========="
}
gradle.beforeProject {
    gradle.println "=========beforeProject========="
}
gradle.afterProject {
    gradle.println "=========afterProject========="
}*/