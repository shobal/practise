import com.android.build.gradle.AppExtension

class ApkAutoInstallExtension {
    Closure nameMap = null
    String destDir = null
}

class ApkAutoInstall implements Plugin<Project> {

    private AppExtension androidExt

    @Override
    void apply(Project target) {
        this.androidExt = target.extensions.getByName("android") as AppExtension
        println 'task add ApkAutoInstall'
        target.extensions.create("apkautoconf", ApkAutoInstallExtension)

        target.task("installApp") << {
            def closure = target['apkautoconf'].nameMap;
            closure('wefdff');
            println project['apkautoconf'].destDir
        }

        /*target.afterEvaluate {
            androidExt.applicationVariants.each { variant ->
                println('00--------0000='+variant.name)
                def javaCompileTask = variant.javaCompiler
                int processorIndex = javaCompileTask.options.compilerArgs.indexOf('-processorpath')
                def processor = javaCompileTask.options.compilerArgs.get(processorIndex + 1)
                processor.split(File.pathSeparator).each { jarPath ->
                    println "----------find compiler jar path: ${jarPath}"
                }
            }
        }*/

    }
}


apply plugin: 'com.android.application'
apply plugin: ApkAutoInstall


task listJars(group: 'myself') {
    doFirst {
        repositories.each {
            //println "repository: ${it.name} ('${it.url}')"
        }

//        println 'xxxxpp:'+repositories.collect { it.name }

//        project.configurations.compile.each { File file -> println 'ooxx----'+file.name }
    }
}

apkautoconf {
    nameMap { arg1 ->
        println('========nameMap=====' + arg1)
    }
    destDir '==========mydddirrr'
}

task scanFileModify(group:'myself') {
    doLast {
        rootProject.subprojects.each {
            if(it.hasProperty('android')){
                println(it.getBuildDir().absolutePath+'==src path='+it.android.sourceSets.main.java.srcDirs[0].absolutePath)
                getDirectory(it.android.sourceSets.main.java.srcDirs[0])
            }
        }
    }
}

def getDirectory(File file) {
    File[] flist = file.listFiles()
    if (flist == null || flist.length == 0) {
        return 0
    }
    for (File f : flist) {
        if (f.isDirectory()) {
            //这里将列出所有的文件夹
//            println("Dir==>" + f.getAbsolutePath())
            getDirectory(f)
        } else {
            //这里将列出所有的文件
            println("file==>" + f.lastModified()+";"+f.getAbsolutePath())
        }
    }
}

task myTest(group:'myself'){
    project.rootProject.subprojects.each { pro ->
        /*pro.afterEvaluate { pj ->
            if (pj.plugins.hasPlugin("com.android.application")) {
                println '777777777777---------======' + pj.name
                def androidExt = pj.extensions.getByName("android") as AppExtension
                androidExt.applicationVariants.each { variant ->
                    def javaCompileTask = variant.javaCompiler
                    int processorIndex = javaCompileTask.options.compilerArgs.indexOf('-processorpath')
                    def processor = javaCompileTask.options.compilerArgs.get(processorIndex + 1)
                    processor.split(File.pathSeparator).each { jarPath ->
                        println pro.name + "----------find compiler jar path: ${jarPath}"
                    }
                }
            }
        }*/
    }
}

task compilesingle(type: JavaCompile,group:'myself') {
    project.afterEvaluate {pro ->
        println '********oopppp*********='+pro.name
        def sdkDirr = android.getBootClasspath()
        def classesList = new ArrayList()
        def androidExt = pro.extensions.getByName("android") as AppExtension

        //self
        File classDir = new File(pro.buildDir,'intermediates/classes/debug')
        if (!classDir.exists() ){
            classDir = new File(pro.buildDir,'intermediates/classes/release')
        }
        classesList.add(classDir.absolutePath)

        //lib
        androidExt.applicationVariants.each { variant ->
            if(variant.name.equals("release")){
                return
            }
            println '*****************='+variant.name
            def javaCompileTask = variant.javaCompiler
            int processorIndex = javaCompileTask.options.compilerArgs.indexOf('-processorpath')
            def processor = javaCompileTask.options.compilerArgs.get(processorIndex + 1)
            processor.split(File.pathSeparator).each { jarPath ->
                classesList.add(jarPath)
                println pro.name + "----------find compiler jar path: ${jarPath}"
            }
        }

        configure {
//            include "com/shobal/gradlepractise/MyContants.java"
            classpath = files(pro.configurations.compile.files,sdkDirr,classesList)
        }
    }

/*    doFirst {
        Properties properties = new Properties()
        InputStream inputStream = project.rootProject.file('local.properties').newDataInputStream()
        properties.load( inputStream )
//        def sdkDirr = properties.getProperty('sdk.dir') +'/platforms/'+project.android.compileSdkVersion+'/android.jar'
        def sdkDirr = android.getBootClasspath()
//        def srcClasses = new File(project.buildDir,'intermediates/classes/debug').absolutePath
        def classesList = new ArrayList()

        project.rootProject.subprojects.each { pro ->
            pro.afterEvaluate { pj ->
                *//*if (pj.plugins.hasPlugin("com.android.application")) {
                    def androidExt = pj.extensions.getByName("android") as AppExtension
                    androidExt.applicationVariants.each { variant ->
                        println '*****************='+variant.name
                        def javaCompileTask = variant.javaCompiler
                        int processorIndex = javaCompileTask.options.compilerArgs.indexOf('-processorpath')
                        def processor = javaCompileTask.options.compilerArgs.get(processorIndex + 1)
                        processor.split(File.pathSeparator).each { jarPath ->
                            classesList.add(jarPath)
                            println pro.name + "----------find compiler jar path: ${jarPath}"
                        }
                    }
                }*//*
            }

            if (pro.hasProperty('android')){
                if (pro.android.hasProperty("libraryRequests")) {
                    println '************00='+pro.buildDir.absolutePath
                    pro.android.libraryRequests.each { p ->
                        println '*****************='+p.name
                    }
                }

                File classDir = new File(pro.buildDir,'intermediates/classes/debug')
                if (!classDir.exists() ){
                    classDir = new File(pro.buildDir,'intermediates/classes/release')
                }
                classesList.add(classDir.absolutePath)
            }else{
                classesList.add(new File(pro.buildDir,'classes').absolutePath)
            }
//            println '===+++'+new File(it.buildDir,'intermediates/classes/debug').absolutePath
        }
//        compilesingle.configure
        configure {
//            include "com/shobal/gradlepractise/MyContants.java"
            classpath = files(project.configurations.compile.files,sdkDirr,classesList)
        }
    }*/

    source = './src/main/java'
    include "com/shobal/gradlepractise/MainActivity.java" //MyContants
    classpath = files(project.configurations.compile)
    destinationDir = file('./bin')
}

configurations.all {
    resolutionStrategy {
        eachDependency { DependencyResolveDetails details ->
            //specifying a fixed version for all libraries with 'org.gradle' group
//            println 'depen:'+details.requested.group+':'+details.requested.name+':'+details.requested.version
        }

//        failOnVersionConflict()
        //preferProjectModules()
    }
}

// Log timings per task.
/*class TimingsListener implements TaskExecutionListener, BuildListener {
    private Clock clock
    private timings = []

    @Override
    void beforeExecute(Task task) {
        clock = new org.gradle.util.Clock()
    }

    @Override
    void afterExecute(Task task, TaskState taskState) {
        def ms = clock.timeInMs
        timings.add([ms, task.path])
        task.project.logger.warn "${task.path} took ${ms}ms"
    }

    @Override
    void buildFinished(BuildResult result) {
        println "Task timings:"
        for (timing in timings) {
            if (timing[0] >= 50) {
                printf "%7sms  %s\n", timing
            }
        }
    }

    @Override
    void buildStarted(Gradle gradle) {}

    @Override
    void projectsEvaluated(Gradle gradle) {}

    @Override
    void projectsLoaded(Gradle gradle) {}

    @Override
    void settingsEvaluated(Settings settings) {}
}

gradle.addListener new TimingsListener()*/

//执行的task的所有依赖
/*gradle.addListener(new TaskExecutionGraphListener() {
    @Override
    void graphPopulated(TaskExecutionGraph graph) {
        gradle.println "=========from gradle.addListener graphPopulated========="
        graph.allTasks.each {
            Task task ->
                gradle.println "=========TaskExecutionGraph:${task.getName()}========="
        }
    }
})*/

//依赖监听
/*gradle.addListener(new DependencyResolutionListener() {
    @Override
    void beforeResolve(ResolvableDependencies resolvableDependencies) {
        gradle.println "DependencyResolutionListener:beforeResolve:=====${dependencies}====="

    }

    @Override
    void afterResolve(ResolvableDependencies resolvableDependencies) {
        gradle.println "DependencyResolutionListener:afterResolve:=====${dependencies}====="

        def projectPath = resolvableDependencies.path.toLowerCase()

        if (projectPath.contains("releasecompile")) {
            gradle.println "[DependencyResolutionListener] release detect:${resolvableDependencies.path}"
            resolvableDependencies.resolutionResult.allDependencies.each { dependency ->
                if (dependency instanceof org.gradle.api.internal.artifacts.result.DefaultUnresolvedDependencyResult) {
                    gradle.println "DefaultUnresolvedDependencyResult reason: ${dependency.reason}"
                    gradle.println "DefaultUnresolvedDependencyResult failure: ${dependency.failure}"
                } else if (dependency instanceof org.gradle.api.internal.artifacts.result.DefaultResolvedDependencyResult) {
                    String selected = dependency.selected
                    def from = dependency.from
                    gradle.println "[DependencyResolutionListener] current dependency:${selected} which is from:${from}"
                    if (selected != null && (selected.toLowerCase().contains("snapshot") || selected.toLowerCase().contains("beta"))) {
                        String errorMessage = "[DependencyResolutionListener] [Error] ${selected} from ${from} contains a snapshot or beta version. you must fix it."
                        gradle.println errorMessage
                        throw new IllegalStateException(errorMessage)
                    }
                }
            }
        }
    }
})*/

//当前构建的任务依赖关系图
/*gradle.taskGraph.whenReady {
    TaskExecutionGraph taskGraph ->
        taskGraph.allTasks.each {
            Task task ->
                gradle.println "=========whenReady:taskGraph:${task.getName()}========="
        }
        taskGraph.beforeTask {
            Task task ->
                gradle.println "=========whenReady:beforeTask:${task.getName()}========="
        }
        taskGraph.afterTask {
            Task task ->
                gradle.println "=========whenReady:afterTask:${task.getName()}========="
        }
}*/
//等同于上面的whenReady闭包中的内容
/*gradle.taskGraph.addTaskExecutionGraphListener(new TaskExecutionGraphListener() {
    @Override
    void graphPopulated(TaskExecutionGraph graph) {
        gradle.println "=========TaskExecutionGraphListener:graphPopulated========="
        graph.allTasks.each {
            Task task ->
                gradle.println "=========TaskExecutionGraph:${task.getName()}========="
        }
    }
})*/

//等同于上面的whenReady闭包中的内容
/*gradle.taskGraph.addTaskExecutionListener(new TaskExecutionListener() {
    @Override
    void beforeExecute(Task task) {
        gradle.println "=========TaskExecutionListener:beforeExecute:${task.getName()}========="

    }

    @Override
    void afterExecute(Task task, TaskState state) {
        gradle.println "=========TaskExecutionListener:afterExecute:${task.getName()}========="
        gradle.println "=========TaskState:[executed]${state.executed}========="
        gradle.println "=========TaskState:[didWork]${state.didWork}========="
        gradle.println "=========TaskState:[failure]${state.failure}========="
        gradle.println "=========TaskState:[skipMessage]${state.skipMessage}========="
        gradle.println "=========TaskState:[skipped]${state.skipped}========="
        gradle.println "=========TaskState:[upToDate]${state.upToDate}========="
    }
})*/

//配置评估监听
/*gradle.addProjectEvaluationListener(new ProjectEvaluationListener() {
    @Override
    void beforeEvaluate(Project project) {
        //项目配置评估前回调
        gradle.println("=========ProjectEvaluationListener:beforeEvaluate ${project.getName()}=========")
    }

    @Override
    void afterEvaluate(Project project, ProjectState state) {
        //项目配置评估后回调
        //如果失败,则failure不为null
        gradle.println("=========ProjectEvaluationListener:afterEvaluate ${state.executed} ${state.failure}=========")
    }
})*/

/**
 * 同上BuildListener和ProjectEvaluationListener
 */
/*gradle.buildFinished {
    gradle.println "=========buildFinished========="
}
gradle.buildStarted {
    gradle.println "=========buildStarted========="
}
gradle.settingsEvaluated {
    gradle.println "=========settingsEvaluated========="
}
gradle.projectsLoaded {
    gradle.println "=========projectsLoaded========="
}
gradle.projectsEvaluated {
    gradle.println "=========projectsEvaluated========="
}
gradle.buildFinished {
    gradle.println "=========buildFinished========="
}
gradle.beforeProject {
    gradle.println "=========beforeProject========="
}
gradle.afterProject {
    gradle.println "=========afterProject========="
}*/

//获得root project
gradle.taskGraph.addTaskExecutionGraphListener(new TaskExecutionGraphListener() {
    @Override
    void graphPopulated(TaskExecutionGraph graph) {
        gradle.println "========${gradle.rootProject}========"
    }
})

gradle.getTaskGraph().whenReady {
    project.tasks.all {
        if (it.name.equalsIgnoreCase('compileJava')) {
            println "=====+++++" + it.getPath()
            printTaskDependency(it, "")
        }
    }
}

void printTaskDependency(Task task, String divider) {
    divider += "-------"
    task.getTaskDependencies().getDependencies(task).any() {
        println('====+++' + divider + it.getPath())
        if (it.getPath().contains(":credit")) {
            printTaskDependency(it, divider)
        }
    }
}


android {
    compileSdkVersion 25
    buildToolsVersion "25.0.2"
    defaultConfig {
        applicationId "com.shobal.gradlepractise"
        minSdkVersion 15
        targetSdkVersion 25
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [tp: "dfsdf"]
                classNames = ["shobal.compilehandler.CompilerProcesser"]
//                includeCompileClassPath true
            }
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    /*lintOptions {
        abortOnError false
    }*/
}



dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    /*androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })*/
    compile 'com.android.support:appcompat-v7:25.3.1'
    compile 'com.android.support:design:25.3.1'
    compile project(':applibrary')
    compile project(':myjavalib')
    compile project(':annotatiom')
    annotationProcessor project(':Compilehandler')

    //testCompile 'junit:junit:4.12'
}

/*-------------*/

class RegisterTransform implements Plugin<Project> {

    @Override
    void apply(Project target) {
        def isApp = target.plugins.hasPlugin(AppPlugin)
        println '-----register MyTransform------' + isApp
        if (isApp) {
            println '-----register MyTransform------' + target.android.bootClasspath[0].toString()
            target.android.registerTransform(new MyTransform(target.android.bootClasspath[0].toString()))
        }
    }
}

import com.android.build.api.transform.*
import com.android.build.gradle.AppExtension
import com.android.build.gradle.AppPlugin
import com.plugin.demo.MyInject
import org.apache.commons.io.FileUtils


class MyTransform extends Transform {
    String mAndClassPath

    public MyTransform(String androidClassPaht) {
        mAndClassPath = androidClassPaht
    }

    @Override
    String getName() {//这个名称会用于生成的gradle task名称
        return "LogInject"
    }

    @Override
    Set<QualifiedContent.ContentType> getInputTypes() {
        //接受输入的类型。我们这里只处理Java类。
        return [QualifiedContent.DefaultContentType.CLASSES]
    }

    @Override
    Set<QualifiedContent.Scope> getScopes() {
        //作用范围。这里我们只处理工程中编写的类。
        return [QualifiedContent.Scope.PROJECT]
    }

    @Override
    boolean isIncremental() {//是否支持增量。这里暂时不实现增量。
        return false
    }

    @Override
    void transform(
            Context context,
            Collection<TransformInput> inputs,
            Collection<TransformInput> referencedInputs,
            TransformOutputProvider outputProvider, boolean isIncremental) throws IOException, TransformException, InterruptedException {
        // Transform的inputs有两种类型，一种是目录，一种是jar包，要分开遍历
        inputs.each { TransformInput input ->
            //对类型为“文件夹”的input进行遍历
            input.directoryInputs.each { DirectoryInput directoryInput ->
                //文件夹里面包含的是我们手写的类以及R.class、BuildConfig.class以及R$XXX.class等
                MyInject.injectDir(directoryInput.file.absolutePath, 'com.shobal.gradlepractise', 'MainActivity', mAndClassPath)

                // 获取output目录
                def dest = outputProvider.getContentLocation(directoryInput.name,
                        directoryInput.contentTypes, directoryInput.scopes,
                        Format.DIRECTORY)

                // 将input的目录复制到output指定目录
                FileUtils.copyDirectory(directoryInput.file, dest)
                println '---------=====' + directoryInput.file.absolutePath + '--copy dir to--' + dest.absolutePath
            }
            //对类型为jar文件的input进行遍历
            input.jarInputs.each { JarInput jarInput ->

                //jar文件一般是第三方依赖库jar文件

                // 重命名输出文件（同目录copyFile会冲突）
                def jarName = jarInput.name
                def md5Name = DigestUtils.md5Hex(jarInput.file.getAbsolutePath())
                if (jarName.endsWith(".jar")) {
                    jarName = jarName.substring(0, jarName.length() - 4)
                }

                //生成输出路径
                def dest = outputProvider.getContentLocation(jarName + md5Name,
                        jarInput.contentTypes, jarInput.scopes, Format.JAR)
                //将输入内容复制到输出
                FileUtils.copyFile(jarInput.file, dest)
                println '---------=====' + jarInput.file.absolutePath + '--copy jar to--' + dest.absolutePath
            }
        }
    }
}

apply plugin: RegisterTransform